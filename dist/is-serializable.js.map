{"version":3,"sources":["../src/is-serializable.ts"],"names":["regexpPlainIdentifier","method","isPlainObject","obj","Object","prototype","toString","call","isSerializable","filename","input","visit","visited","value","path","has","SerializableError","get","set","refs","type","entries","every","key","nestedValue","nextPath","test","JSON","stringify","newRefs","Map","Array","isArray","index"],"mappings":"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","sourcesContent":["// this copied and pasted from is from next.js\n// https://github.com/vercel/next.js/blob/235b4cd0a879c947a7b6906c75f1a1b0ba53ce62/packages/next/lib/is-serializable-props.ts\nimport { SerializableError } from 'next/dist/lib/is-serializable-props';\n\nconst regexpPlainIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nconst method = 'preval';\n\nfunction isPlainObject(obj: any): boolean {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isSerializable(filename: string, input: any): true {\n  function visit(visited: Map<any, string>, value: any, path: string) {\n    if (visited.has(value)) {\n      throw new SerializableError(\n        filename,\n        method,\n        path,\n        `Circular references cannot be expressed in JSON (references: \\`${\n          visited.get(value) || '(self)'\n        }\\`).`\n      );\n    }\n\n    visited.set(value, path);\n  }\n\n  function isSerializable(\n    refs: Map<any, string>,\n    value: any,\n    path: string\n  ): true {\n    const type = typeof value;\n    if (\n      // `null` can be serialized, but not `undefined`.\n      value === null ||\n      // n.b. `bigint`, `function`, `symbol`, and `undefined` cannot be\n      // serialized.\n      //\n      // `object` is special-cased below, as it may represent `null`, an Array,\n      // a plain object, a class, et al.\n      type === 'boolean' ||\n      type === 'number' ||\n      type === 'string'\n    ) {\n      return true;\n    }\n\n    if (type === 'undefined') {\n      throw new SerializableError(\n        filename,\n        method,\n        path,\n        '`undefined` cannot be serialized as JSON. Please use `null` or omit this value.'\n      );\n    }\n\n    if (isPlainObject(value)) {\n      visit(refs, value, path);\n\n      if (\n        Object.entries(value).every(([key, nestedValue]) => {\n          const nextPath = regexpPlainIdentifier.test(key)\n            ? `${path}.${key}`\n            : `${path}[${JSON.stringify(key)}]`;\n\n          const newRefs = new Map(refs);\n          return (\n            isSerializable(newRefs, key, nextPath) &&\n            isSerializable(newRefs, nestedValue, nextPath)\n          );\n        })\n      ) {\n        return true;\n      }\n\n      throw new SerializableError(\n        filename,\n        method,\n        path,\n        `invariant: Unknown error encountered in Object.`\n      );\n    }\n\n    if (Array.isArray(value)) {\n      visit(refs, value, path);\n\n      if (\n        value.every((nestedValue, index) => {\n          const newRefs = new Map(refs);\n          return isSerializable(newRefs, nestedValue, `${path}[${index}]`);\n        })\n      ) {\n        return true;\n      }\n\n      throw new SerializableError(\n        filename,\n        method,\n        path,\n        `invariant: Unknown error encountered in Array.`\n      );\n    }\n\n    // None of these can be expressed as JSON:\n    // const type: \"bigint\" | \"symbol\" | \"object\" | \"function\"\n    throw new SerializableError(\n      filename,\n      method,\n      path,\n      '`' +\n        type +\n        '`' +\n        (type === 'object'\n          ? ` (\"${Object.prototype.toString.call(value)}\")`\n          : '') +\n        ' cannot be serialized as JSON. Please only return JSON serializable data types.'\n    );\n  }\n\n  return isSerializable(new Map(), input, '');\n}\n\nexport default isSerializable;\n"],"file":"is-serializable.js"}